// ********RoostGPT********
/*
Test generated by RoostGPT for test test-workflow using AI Type Open AI and AI Model gpt-4o-2024-05-13
ROOST_METHOD_HASH=hasAdventure_42546fdbc4
ROOST_METHOD_SIG_HASH=hasAdventure_69867bba11
Certainly! Here are multiple JUnit test scenarios for the `hasAdventure` method:
```
Scenario 1: Check Adventure in Empty Adventures Set
Details:
  TestName: checkAdventureInEmptySet
  Description: Verify that the method returns false when the adventures set is empty.
  Execution:
    Arrange: Create an instance of the class with an empty adventures set.
    Act: Call the `hasAdventure` method with a specific Adventure object.
    Assert: Use JUnit assertions to check that the method returns false.
  Validation:
    This test checks that the method correctly identifies that an adventure is not present in an empty set, ensuring the initial state is handled correctly.
```
```
Scenario 2: Check Adventure Present in Adventures Set
Details:
  TestName: checkAdventurePresentInSet
  Description: Verify that the method returns true when the adventure is present in the adventures set.
  Execution:
    Arrange: Create an instance of the class and add a specific Adventure object to the adventures set.
    Act: Call the `hasAdventure` method with the same Adventure object.
    Assert: Use JUnit assertions to check that the method returns true.
  Validation:
    This test checks that the method can correctly identify an existing adventure in the set, confirming proper functionality for positive cases.
```
```
Scenario 3: Check Adventure Not Present in Adventures Set
Details:
  TestName: checkAdventureNotPresentInSet
  Description: Verify that the method returns false when the adventure is not present in the adventures set.
  Execution:
    Arrange: Create an instance of the class and add a different Adventure object to the adventures set.
    Act: Call the `hasAdventure` method with an Adventure object that is not in the set.
    Assert: Use JUnit assertions to check that the method returns false.
  Validation:
    This test ensures that the method can correctly identify when an adventure is not in the set, verifying accuracy in negative cases.
```
```
Scenario 4: Check Null Adventure Parameter
Details:
  TestName: checkNullAdventureParameter
  Description: Verify that the method handles a null Adventure parameter gracefully.
  Execution:
    Arrange: Create an instance of the class.
    Act: Call the `hasAdventure` method with a null Adventure object.
    Assert: Use JUnit assertions to check that the method returns false.
  Validation:
    This test checks that the method can handle null input without throwing an exception, ensuring robustness and defensive programming.
```
```
Scenario 5: Check Adventure in a Large Adventures Set
Details:
  TestName: checkAdventureInLargeSet
  Description: Verify that the method returns true when the adventure is present in a large adventures set.
  Execution:
    Arrange: Create an instance of the class and add a large number of Adventure objects to the adventures set, including the specific Adventure object to be tested.
    Act: Call the `hasAdventure` method with the specific Adventure object.
    Assert: Use JUnit assertions to check that the method returns true.
  Validation:
    This test ensures that the method performs correctly even with a large data set, verifying scalability and performance.
```
```
Scenario 6: Check Adventure Not in a Large Adventures Set
Details:
  TestName: checkAdventureNotInLargeSet
  Description: Verify that the method returns false when the adventure is not present in a large adventures set.
  Execution:
    Arrange: Create an instance of the class and add a large number of Adventure objects to the adventures set, excluding the specific Adventure object to be tested.
    Act: Call the `hasAdventure` method with the specific Adventure object.
    Assert: Use JUnit assertions to check that the method returns false.
  Validation:
    This test ensures that the method accurately identifies the absence of an adventure in a large data set, verifying accuracy and performance.
```
```
Scenario 7: Check Same Adventure Object Multiple Times
Details:
  TestName: checkSameAdventureMultipleTimes
  Description: Verify that the method consistently returns true when the same Adventure object is checked multiple times.
  Execution:
    Arrange: Create an instance of the class and add a specific Adventure object to the adventures set.
    Act: Call the `hasAdventure` method multiple times with the same Adventure object.
    Assert: Use JUnit assertions to check that the method returns true each time.
  Validation:
    This test ensures that the method is consistent in its results, verifying reliability.
```
These test scenarios cover various aspects of the `hasAdventure` method, including edge cases and error handling. They help ensure that the method behaves correctly under different conditions.
*/
// ********RoostGPT********
package pt.ulisboa.tecnico.softeng.broker.domain;

import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.runners.MockitoJUnitRunner;
import static org.junit.Assert.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pt.ulisboa.tecnico.softeng.broker.exception.BrokerException;
import org.junit.experimental.categories.Category;

@Category({ Categories.hasAdventure.class, Categories.roostTest1.class, Categories.roostTest2.class })
@RunWith(MockitoJUnitRunner.class)
public class BrokerHasAdventureTest {

	@Mock
	private static Logger logger = LoggerFactory.getLogger(Broker.class);

	public static Set<Broker> brokers = new HashSet<>();

	@InjectMocks
	private Broker broker;

	@Before
	public void setUp() {
		MockitoAnnotations.initMocks(this);
		broker = new Broker("CODE1", "BrokerName");
	}

	@Test
	public void checkAdventureInEmptySet() {
		Adventure adventure = new Adventure(broker, LocalDate.now(), LocalDate.now().plusDays(5), 30,
				"PT50000000000000000000000", 1000);
		assertFalse(broker.hasAdventure(adventure));
	}

	@Test
	public void checkAdventurePresentInSet() {
		Adventure adventure = new Adventure(broker, LocalDate.now(), LocalDate.now().plusDays(5), 30,
				"PT50000000000000000000000", 1000);
		broker.addAdventure(adventure);
		assertTrue(broker.hasAdventure(adventure));
	}

	@Test
	public void checkAdventureNotPresentInSet() {
		Adventure adventure1 = new Adventure(broker, LocalDate.now(), LocalDate.now().plusDays(5), 30,
				"PT50000000000000000000000", 1000);
		Adventure adventure2 = new Adventure(broker, LocalDate.now().plusDays(1), LocalDate.now().plusDays(6), 25,
				"PT50000000000000000000001", 1500);
		broker.addAdventure(adventure1);
		assertFalse(broker.hasAdventure(adventure2));
	}

	@Test
	public void checkNullAdventureParameter() {
		assertFalse(broker.hasAdventure(null));
	}

	@Test
	public void checkAdventureInLargeSet() {
		Adventure adventure = new Adventure(broker, LocalDate.now(), LocalDate.now().plusDays(5), 30,
				"PT50000000000000000000000", 1000);
		for (int i = 0; i < 1000; i++) {
			broker.addAdventure(new Adventure(broker, LocalDate.now().plusDays(i), LocalDate.now().plusDays(i + 5), 30,
					"PT5000000000000000000000" + i, 1000));
		}
		broker.addAdventure(adventure);
		assertTrue(broker.hasAdventure(adventure));
	}

	@Test
	public void checkAdventureNotInLargeSet() {
		Adventure adventure = new Adventure(broker, LocalDate.now(), LocalDate.now().plusDays(5), 30,
				"PT50000000000000000000000", 1000);
		for (int i = 0; i < 1000; i++) {
			broker.addAdventure(new Adventure(broker, LocalDate.now().plusDays(i), LocalDate.now().plusDays(i + 5), 30,
					"PT5000000000000000000000" + i, 1000));
		}
		assertFalse(broker.hasAdventure(adventure));
	}

	@Test
	public void checkSameAdventureMultipleTimes() {
		Adventure adventure = new Adventure(broker, LocalDate.now(), LocalDate.now().plusDays(5), 30,
				"PT50000000000000000000000", 1000);
		broker.addAdventure(adventure);
		assertTrue(broker.hasAdventure(adventure));
		assertTrue(broker.hasAdventure(adventure));
		assertTrue(broker.hasAdventure(adventure));
	}

}
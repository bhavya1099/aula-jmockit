// ********RoostGPT********
/*
Test generated by RoostGPT for test test-workflow using AI Type Open AI and AI Model gpt-4o-2024-05-13
ROOST_METHOD_HASH=getActivityBooking_c995b29107
ROOST_METHOD_SIG_HASH=getActivityBooking_0052550344
```
Scenario 1: Retrieve Default Activity Booking
Details:
  TestName: retrieveDefaultActivityBooking
  Description: Check if the method getActivityBooking returns the default value of the activityBooking field, which is null.
Execution:
  Arrange: Create an instance of the class containing the getActivityBooking method without modifying the activityBooking field.
  Act: Call the getActivityBooking method.
  Assert: Use JUnit assertions to check that the returned value is null.
Validation:
  Verify that the method correctly returns the default value of the activityBooking field. This test ensures that the method behaves as expected when no activity booking is set.

Scenario 2: Retrieve Non-Default Activity Booking
Details:
  TestName: retrieveNonDefaultActivityBooking
  Description: Check if the method getActivityBooking returns the value of the activityBooking field when it has been set to a non-default value.
Execution:
  Arrange: Create an instance of the class and set the activityBooking field to a specific value using reflection because the field is private.
  Act: Call the getActivityBooking method.
  Assert: Use JUnit assertions to check that the returned value matches the value set in the activityBooking field.
Validation:
  Verify that the method correctly returns the value of the activityBooking field when it has been modified. This test ensures that the method is capable of retrieving updated values.
Scenario 3: Log Activity Booking Retrieval
Details:
  TestName: logActivityBookingRetrieval
  Description: Check if the method getActivityBooking logs the retrieval of the activity booking.
Execution:
  Arrange: Create an instance of the class and configure the logger to capture log messages.
  Act: Call the getActivityBooking method.
  Assert: Use JUnit assertions to verify that the expected log message is generated.
Validation:
  Verify that the method logs the activity booking retrieval correctly. This test ensures that logging is performed as expected, which is important for debugging and monitoring.
Scenario 4: Activity Booking Not Affected by Other Fields
Details:
  TestName: activityBookingNotAffectedByOtherFields
  Description: Check if the method getActivityBooking returns the correct value of the activityBooking field regardless of changes to other fields in the class.
Execution:
  Arrange: Create an instance of the class, modify other fields like roomBooking and bankPayment using reflection, and set the activityBooking field to a specific value.
  Act: Call the getActivityBooking method.
  Assert: Use JUnit assertions to check that the returned value matches the value set in the activityBooking field.
Validation:
  Verify that the method correctly returns the value of the activityBooking field without being influenced by modifications to other fields. This test ensures the method's behavior is isolated and consistent.
Scenario 5: Multiple Instances with Different Activity Bookings
Details:
  TestName: multipleInstancesWithDifferentActivityBookings
  Description: Check if the method getActivityBooking returns the correct value for multiple instances of the class, each with a different activityBooking value.
Execution:
  Arrange: Create multiple instances of the class and set different values for the activityBooking field in each instance using reflection.
  Act: Call the getActivityBooking method on each instance.
  Assert: Use JUnit assertions to check that the returned value matches the value set in the activityBooking field for each instance.
Validation:
  Verify that the method correctly returns the value of the activityBooking field for each instance independently. This test ensures that the method's behavior is instance-specific and does not cause interference between instances.

Scenario 6: Null Activity Booking After Initialization
Details:
  TestName: nullActivityBookingAfterInitialization
  Description: Check if the method getActivityBooking returns null immediately after the class instance is created, ensuring no initial value is set.
Execution:
  Arrange: Create an instance of the class without modifying the activityBooking field.
  Act: Call the getActivityBooking method immediately after initialization.
  Assert: Use JUnit assertions to check that the returned value is null.
Validation:
  Verify that the method correctly returns null when the class instance is freshly created. This test ensures that the activityBooking field is not pre-initialized with a non-null value.

Scenario 7: Activity Booking with Special Characters
Details:
  TestName: activityBookingWithSpecialCharacters
  Description: Check if the method getActivityBooking returns the correct value when the activityBooking field contains special characters.
Execution:
  Arrange: Create an instance of the class and set the activityBooking field to a string containing special characters using reflection.
  Act: Call the getActivityBooking method.
  Assert: Use JUnit assertions to check that the returned value matches the string with special characters set in the activityBooking field.
Validation:
  Verify that the method correctly handles and returns values with special characters. This test ensures the method's robustness in handling diverse input values.
```
*/
// ********RoostGPT********
package pt.ulisboa.tecnico.softeng.broker.domain;

import org.joda.time.LocalDate;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pt.ulisboa.tecnico.softeng.broker.interfaces.ActivityInterface;
import pt.ulisboa.tecnico.softeng.broker.interfaces.BankInterface;
import pt.ulisboa.tecnico.softeng.broker.interfaces.HotelInterface;
import java.lang.reflect.Field;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;
import pt.ulisboa.tecnico.softeng.hotel.domain.Room;
import org.junit.experimental.categories.Category;

@Category({ Categories.getActivityBooking.class, Categories.roostTest1.class, Categories.roostTest2.class })
public class AdventureGetActivityBookingTest {

	private static final Logger logger = LoggerFactory.getLogger(Adventure.class);

	private Broker broker;

	private Adventure adventure;

	@Before
	public void setUp() {
		broker = new Broker("BROKER1", "BrokerName");
		adventure = new Adventure(broker, new LocalDate(), new LocalDate().plusDays(1), 30, "IBAN", 1000);
	}

	@Test
	public void retrieveDefaultActivityBooking() {
		assertNull(adventure.getActivityBooking());
	}

	@Test
	public void retrieveNonDefaultActivityBooking() throws NoSuchFieldException, IllegalAccessException {
		Field field = Adventure.class.getDeclaredField("activityBooking");
		field.setAccessible(true);
		field.set(adventure, "ACTIVITY123");
		assertEquals("ACTIVITY123", adventure.getActivityBooking());
	}

	@Test
	public void logActivityBookingRetrieval() {
		Logger mockLogger = Mockito.mock(Logger.class);
		Field loggerField;
		try {
			loggerField = Adventure.class.getDeclaredField("logger");
			loggerField.setAccessible(true);
			loggerField.set(null, mockLogger);
			adventure.getActivityBooking();
			Mockito.verify(mockLogger).info(Mockito.anyString());
		}
		catch (NoSuchFieldException | IllegalAccessException e) {
			e.printStackTrace();
		}
	}

	@Test
	public void activityBookingNotAffectedByOtherFields() throws NoSuchFieldException, IllegalAccessException {
		Field roomBookingField = Adventure.class.getDeclaredField("roomBooking");
		roomBookingField.setAccessible(true);
		roomBookingField.set(adventure, "ROOM123");
		Field bankPaymentField = Adventure.class.getDeclaredField("bankPayment");
		bankPaymentField.setAccessible(true);
		bankPaymentField.set(adventure, "PAYMENT123");
		Field activityBookingField = Adventure.class.getDeclaredField("activityBooking");
		activityBookingField.setAccessible(true);
		activityBookingField.set(adventure, "ACTIVITY123");
		assertEquals("ACTIVITY123", adventure.getActivityBooking());
	}

	@Test
	public void multipleInstancesWithDifferentActivityBookings() throws NoSuchFieldException, IllegalAccessException {
		Adventure adventure1 = new Adventure(broker, new LocalDate(), new LocalDate().plusDays(1), 30, "IBAN", 1000);
		Adventure adventure2 = new Adventure(broker, new LocalDate(), new LocalDate().plusDays(1), 30, "IBAN", 1000);
		Field activityBookingField1 = Adventure.class.getDeclaredField("activityBooking");
		activityBookingField1.setAccessible(true);
		activityBookingField1.set(adventure1, "ACTIVITY123");
		Field activityBookingField2 = Adventure.class.getDeclaredField("activityBooking");
		activityBookingField2.setAccessible(true);
		activityBookingField2.set(adventure2, "ACTIVITY456");
		assertEquals("ACTIVITY123", adventure1.getActivityBooking());
		assertEquals("ACTIVITY456", adventure2.getActivityBooking());
	}

	@Test
	public void nullActivityBookingAfterInitialization() {
		assertNull(adventure.getActivityBooking());
	}

	@Test
	public void activityBookingWithSpecialCharacters() throws NoSuchFieldException, IllegalAccessException {
		Field field = Adventure.class.getDeclaredField("activityBooking");
		field.setAccessible(true);
		field.set(adventure, "ACTIVITY@#$%");
		assertEquals("ACTIVITY@#$%", adventure.getActivityBooking());
	}

}
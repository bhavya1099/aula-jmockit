// ********RoostGPT********
/*
Test generated by RoostGPT for test test-workflow using AI Type Open AI and AI Model gpt-4o-2024-05-13
ROOST_METHOD_HASH=addAdventure_54a6c725b4
ROOST_METHOD_SIG_HASH=addAdventure_e25af62412
Sure, here are several JUnit test scenarios for the `addAdventure` method, considering the provided class fields and imports:
```
Scenario 1: Adding a New Adventure to an Empty Set
Details:
  TestName: addNewAdventureToEmptySet
  Description: This test checks if a new Adventure object is successfully added to an empty set of adventures.
Execution:
  Arrange: Create an instance of the class containing the addAdventure method. Initialize an Adventure object.
  Act: Call the addAdventure method with the created Adventure object.
  Assert: Verify that the adventures set contains the added Adventure object.
Validation:
  This assertion ensures that the addAdventure method correctly adds a new Adventure object to the adventures set, which is initially empty. It verifies the basic functionality of adding an adventure.
```
```
Scenario 2: Adding a New Adventure to a Non-Empty Set
Details:
  TestName: addNewAdventureToNonEmptySet
  Description: This test checks if a new Adventure object is successfully added to a non-empty set of adventures.
Execution:
  Arrange: Create an instance of the class containing the addAdventure method. Initialize an Adventure object and add an existing Adventure object to the adventures set.
  Act: Call the addAdventure method with the new Adventure object.
  Assert: Verify that the adventures set contains both the existing and the new Adventure objects.
Validation:
  This assertion ensures that the addAdventure method correctly adds a new Adventure object to a set that already contains other Adventure objects, maintaining the integrity of the set.
```
```
Scenario 3: Adding a Duplicate Adventure
Details:
  TestName: addDuplicateAdventure
  Description: This test checks if adding a duplicate Adventure object to the adventures set does not result in duplicate entries.
Execution:
  Arrange: Create an instance of the class containing the addAdventure method. Initialize an Adventure object and add it to the adventures set.
  Act: Call the addAdventure method with the same Adventure object.
  Assert: Verify that the adventures set still contains only one instance of the Adventure object.
Validation:
  This assertion ensures that the addAdventure method respects the Set contract, which does not allow duplicate entries. It verifies that the method does not introduce duplicates.
```
```
Scenario 4: Adding a Null Adventure
Details:
  TestName: addNullAdventure
  Description: This test checks if adding a null Adventure object to the adventures set throws the appropriate exception.
Execution:
  Arrange: Create an instance of the class containing the addAdventure method.
  Act: Call the addAdventure method with a null Adventure object.
  Assert: Verify that the method throws a NullPointerException or a custom exception, such as BrokerException.
Validation:
  This assertion ensures that the addAdventure method handles null inputs appropriately by throwing an exception. It verifies the method's robustness against invalid inputs.
```
```
Scenario 5: Logging Addition of Adventure
Details:
  TestName: logAdditionOfAdventure
  Description: This test checks if adding an Adventure object to the adventures set triggers the appropriate logging.
Execution:
  Arrange: Create an instance of the class containing the addAdventure method. Initialize an Adventure object. Mock the logger to capture log messages.
  Act: Call the addAdventure method with the Adventure object.
  Assert: Verify that the logger logs the addition of the Adventure object.
Validation:
  This assertion ensures that the addAdventure method includes logging functionality, which can be crucial for monitoring and debugging. It verifies that the method logs the addition of adventures as expected.
```
```
Scenario 6: Adding Multiple Adventures
Details:
  TestName: addMultipleAdventures
  Description: This test checks if multiple Adventure objects are successfully added to the adventures set.
Execution:
  Arrange: Create an instance of the class containing the addAdventure method. Initialize multiple Adventure objects.
  Act: Call the addAdventure method with each Adventure object.
  Assert: Verify that the adventures set contains all the added Adventure objects.
Validation:
  This assertion ensures that the addAdventure method can handle multiple additions and maintains all added Adventure objects in the set. It verifies the method's capability to handle multiple inputs.
```
```
Scenario 7: Adding Adventure with Special Characters
Details:
  TestName: addAdventureWithSpecialCharacters
  Description: This test checks if adding an Adventure object with special characters in its attributes is successfully added to the adventures set.
Execution:
  Arrange: Create an instance of the class containing the addAdventure method. Initialize an Adventure object with special characters in its attributes.
  Act: Call the addAdventure method with the Adventure object.
  Assert: Verify that the adventures set contains the added Adventure object.
Validation:
  This assertion ensures that the addAdventure method can handle Adventure objects with special characters in their attributes without any issues. It verifies the method's robustness against different character sets.
```
These scenarios cover a variety of cases, including edge cases and error handling for the `addAdventure` method.
*/
// ********RoostGPT********
package pt.ulisboa.tecnico.softeng.broker.domain;

import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set;
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;
import pt.ulisboa.tecnico.softeng.broker.exception.BrokerException;
import org.junit.experimental.categories.Category;

@Category({ Categories.addAdventure.class, Categories.roostTest1.class, Categories.roostTest2.class })
public class BrokerAddAdventureTest {

	private static final Logger logger = LoggerFactory.getLogger(Broker.class);

	public static final Set<Broker> brokers = new HashSet<>();

	private Broker broker;

	private Adventure adventure;

	@Before
	public void setUp() {
		broker = new Broker("BROKER1", "Broker Test");
		adventure = new Adventure(broker, LocalDate.now(), LocalDate.now().plusDays(5), 25, "IBAN123", 1000);
	}

	@Test
	public void addNewAdventureToEmptySet() {
		broker.addAdventure(adventure);
		assertTrue(broker.getAdventures().contains(adventure));
	}

	@Test
	public void addNewAdventureToNonEmptySet() {
		broker.addAdventure(adventure);
		Adventure newAdventure = new Adventure(broker, LocalDate.now().plusDays(10), LocalDate.now().plusDays(15), 30,
				"IBAN456", 1500);
		broker.addAdventure(newAdventure);
		assertTrue(broker.getAdventures().contains(adventure));
		assertTrue(broker.getAdventures().contains(newAdventure));
	}

	@Test
	public void addDuplicateAdventure() {
		broker.addAdventure(adventure);
		broker.addAdventure(adventure);
		assertEquals(1, broker.getAdventures().size());
	}

	@Test(expected = NullPointerException.class)
	public void addNullAdventure() {
		broker.addAdventure(null);
	}

	@Test
	public void logAdditionOfAdventure() {
		Logger mockLogger = mock(Logger.class);
		// Assuming logger is static, we need to mock static methods
		try (MockedStatic<LoggerFactory> mockedLoggerFactory = Mockito.mockStatic(LoggerFactory.class)) {
			mockedLoggerFactory.when(() -> LoggerFactory.getLogger(Broker.class)).thenReturn(mockLogger);
			broker.addAdventure(adventure);
			verify(mockLogger).debug(anyString(), any(Object[].class));
		}
	}

	@Test
	public void addMultipleAdventures() {
		Adventure adventure2 = new Adventure(broker, LocalDate.now().plusDays(10), LocalDate.now().plusDays(15), 30,
				"IBAN456", 1500);
		Adventure adventure3 = new Adventure(broker, LocalDate.now().plusDays(20), LocalDate.now().plusDays(25), 35,
				"IBAN789", 2000);
		broker.addAdventure(adventure);
		broker.addAdventure(adventure2);
		broker.addAdventure(adventure3);
		assertTrue(broker.getAdventures().contains(adventure));
		assertTrue(broker.getAdventures().contains(adventure2));
		assertTrue(broker.getAdventures().contains(adventure3));
	}

	@Test
	public void addAdventureWithSpecialCharacters() {
		Adventure specialCharAdventure = new Adventure(broker, LocalDate.now(), LocalDate.now().plusDays(5), 25,
				"IBAN@!#$%^&*", 1000);
		broker.addAdventure(specialCharAdventure);
		assertTrue(broker.getAdventures().contains(specialCharAdventure));
	}

}
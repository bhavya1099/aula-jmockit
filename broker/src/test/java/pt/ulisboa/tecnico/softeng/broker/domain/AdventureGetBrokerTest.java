// ********RoostGPT********
/*
Test generated by RoostGPT for test test-workflow using AI Type Open AI and AI Model gpt-4o-2024-05-13
ROOST_METHOD_HASH=getBroker_bcd1d65c25
ROOST_METHOD_SIG_HASH=getBroker_39d1f697c8
```
Scenario 1: Verify Broker Object is Returned
Details:
  TestName: getBrokerReturnsBrokerObject.
  Description: Check if the getBroker method returns the broker object that is a private final field in the class.
Execution:
  Arrange: Ensure that the broker field is initialized with a valid Broker object.
  Act: Call the getBroker method.
  Assert: Use JUnit assertions to verify that the returned object is the same as the broker field.
Validation:
  This test ensures that the getBroker method correctly returns the broker object, validating the correct implementation of the getter method.
Scenario 2: Broker Field is Null
Details:
  TestName: getBrokerReturnsNullWhenBrokerIsNull.
  Description: Check if the getBroker method returns null when the broker field is not initialized (default state).
Execution:
  Arrange: Ensure that the broker field is not initialized (it remains null).
  Act: Call the getBroker method.
  Assert: Use JUnit assertions to verify that the returned value is null.
Validation:
  This test ensures that the getBroker method handles the scenario where the broker field is null and returns null appropriately.
Scenario 3: Logger Interaction During Method Call
Details:
  TestName: getBrokerDoesNotInteractWithLogger.
  Description: Verify that calling the getBroker method does not interact with the Logger instance.
Execution:
  Arrange: Set up a mock Logger instance to verify interactions.
  Act: Call the getBroker method.
  Assert: Use Mockito to verify that no interactions with the Logger instance occurred.
Validation:
  This test ensures that the getBroker method does not perform any logging operations, validating that it strictly returns the broker object.
Scenario 4: Ensure No Side Effects on Static Fields
Details:
  TestName: getBrokerDoesNotModifyStaticFields.
  Description: Check that calling the getBroker method does not modify any static fields like logger or counter.
Execution:
  Arrange: Record the initial state of static fields (logger and counter).
  Act: Call the getBroker method.
  Assert: Use JUnit assertions to verify that the static fields remain unchanged.
Validation:
  This test ensures that the getBroker method does not produce any side effects on static fields, maintaining the class's state consistency.
Scenario 5: Ensure No Modification to Other Fields
Details:
  TestName: getBrokerDoesNotModifyOtherFields.
  Description: Verify that calling the getBroker method does not modify any other fields in the class.
Execution:
  Arrange: Record the initial state of all fields (ID, begin, end, age, IBAN, amount, bankPayment, roomBooking, activityBooking).
  Act: Call the getBroker method.
  Assert: Use JUnit assertions to verify that the state of all fields remains unchanged.
Validation:
  This test ensures that the getBroker method is purely a getter and does not modify any other fields, ensuring data integrity.
Scenario 6: Test Broker Initialization
Details:
  TestName: getBrokerReturnsInitializedBroker.
  Description: Verify that the getBroker method returns a correctly initialized Broker object if the broker field is set.
Execution:
  Arrange: Initialize the broker field with a specific Broker object.
  Act: Call the getBroker method.
  Assert: Use JUnit assertions to verify that the returned Broker object matches the initialized object.
Validation:
  This test ensures that the getBroker method returns the exact Broker object that was initialized, confirming the correct behavior of the getter method.
```
*/
// ********RoostGPT********
package pt.ulisboa.tecnico.softeng.broker.domain;

import org.joda.time.LocalDate;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.MockitoJUnitRunner;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import static org.junit.Assert.*;
import pt.ulisboa.tecnico.softeng.broker.interfaces.ActivityInterface;
import pt.ulisboa.tecnico.softeng.broker.interfaces.BankInterface;
import pt.ulisboa.tecnico.softeng.broker.interfaces.HotelInterface;
import pt.ulisboa.tecnico.softeng.hotel.domain.Room;

@RunWith(MockitoJUnitRunner.class)
public class AdventureGetBrokerTest {

	private static final Logger logger = LoggerFactory.getLogger(Adventure.class);

	private static int counter = 0;

	private Adventure adventure;

	private Broker broker;

	@Mock
	private Logger mockLogger;

	@Before
	public void setUp() {
		broker = new Broker("B1", "Broker1");
		adventure = new Adventure(broker, new LocalDate(), new LocalDate().plusDays(1), 25, "IBAN123", 1000);
	}

	@Test
	public void getBrokerReturnsBrokerObject() {
		Broker result = adventure.getBroker();
		assertSame(broker, result);
	}

	@Test
	public void getBrokerReturnsNullWhenBrokerIsNull() {
		Adventure adventureWithNullBroker = new Adventure(null, new LocalDate(), new LocalDate().plusDays(1), 25,
				"IBAN123", 1000);
		Broker result = adventureWithNullBroker.getBroker();
		assertNull(result);
	}

	@Test
	public void getBrokerDoesNotInteractWithLogger() {
		Adventure adventureWithMockLogger = new Adventure(broker, new LocalDate(), new LocalDate().plusDays(1), 25,
				"IBAN123", 1000);
		adventureWithMockLogger.getBroker();
		Mockito.verify(mockLogger, Mockito.never()).info(Mockito.anyString());
	}

	@Test
	public void getBrokerDoesNotModifyStaticFields() {
		int initialCounter = counter;
		Logger initialLogger = logger;
		adventure.getBroker();
		assertEquals(initialCounter, counter);
		assertSame(initialLogger, logger);
	}

	@Test
	public void getBrokerDoesNotModifyOtherFields() {
		String initialID = adventure.ID;
		LocalDate initialBegin = adventure.begin;
		LocalDate initialEnd = adventure.end;
		int initialAge = adventure.age;
		String initialIBAN = adventure.IBAN;
		int initialAmount = adventure.amount;
		String initialBankPayment = adventure.bankPayment;
		String initialRoomBooking = adventure.roomBooking;
		String initialActivityBooking = adventure.activityBooking;
		adventure.getBroker();
		assertEquals(initialID, adventure.ID);
		assertEquals(initialBegin, adventure.begin);
		assertEquals(initialEnd, adventure.end);
		assertEquals(initialAge, adventure.age);
		assertEquals(initialIBAN, adventure.IBAN);
		assertEquals(initialAmount, adventure.amount);
		assertEquals(initialBankPayment, adventure.bankPayment);
		assertEquals(initialRoomBooking, adventure.roomBooking);
		assertEquals(initialActivityBooking, adventure.activityBooking);
	}

	@Test    public void getBrokerReturnsInitializedBroker() {        Broker result = adventure.getBroker();        assertSame(broker, result);
import org.junit.experimental.categories.Category;
import org.junit.Test;

@Category({Categories.getBroker.class,Categories.roostTest1.class,Categories.roostTest2.class})    }

}
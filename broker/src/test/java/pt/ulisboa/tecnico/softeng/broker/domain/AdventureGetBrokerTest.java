// ********RoostGPT********
/*
Test generated by RoostGPT for test test-workflow using AI Type Open AI and AI Model gpt-4o-2024-05-13
ROOST_METHOD_HASH=getBroker_bcd1d65c25
ROOST_METHOD_SIG_HASH=getBroker_39d1f697c8
```
Scenario 1: Verify Broker Object is Returned
Details:
  TestName: getBrokerReturnsBrokerObject.
  Description: Check if the getBroker method returns the broker object that is a private final field in the class.
Execution:
  Arrange: Ensure that the broker field is initialized with a valid Broker object.
  Act: Call the getBroker method.
  Assert: Use JUnit assertions to verify that the returned object is the same as the broker field.
Validation:
  This test ensures that the getBroker method correctly returns the broker object, validating the correct implementation of the getter method.
Scenario 2: Broker Field is Null
Details:
  TestName: getBrokerReturnsNullWhenBrokerIsNull.
  Description: Check if the getBroker method returns null when the broker field is not initialized (default state).
Execution:
  Arrange: Ensure that the broker field is not initialized (it remains null).
  Act: Call the getBroker method.
  Assert: Use JUnit assertions to verify that the returned value is null.
Validation:
  This test ensures that the getBroker method handles the scenario where the broker field is null and returns null appropriately.
Scenario 3: Logger Interaction During Method Call
Details:
  TestName: getBrokerDoesNotInteractWithLogger.
  Description: Verify that calling the getBroker method does not interact with the Logger instance.
Execution:
  Arrange: Set up a mock Logger instance to verify interactions.
  Act: Call the getBroker method.
  Assert: Use Mockito to verify that no interactions with the Logger instance occurred.
Validation:
  This test ensures that the getBroker method does not perform any logging operations, validating that it strictly returns the broker object.
Scenario 4: Ensure No Side Effects on Static Fields
Details:
  TestName: getBrokerDoesNotModifyStaticFields.
  Description: Check that calling the getBroker method does not modify any static fields like logger or counter.
Execution:
  Arrange: Record the initial state of static fields (logger and counter).
  Act: Call the getBroker method.
  Assert: Use JUnit assertions to verify that the static fields remain unchanged.
Validation:
  This test ensures that the getBroker method does not produce any side effects on static fields, maintaining the class's state consistency.
Scenario 5: Ensure No Modification to Other Fields
Details:
  TestName: getBrokerDoesNotModifyOtherFields.
  Description: Verify that calling the getBroker method does not modify any other fields in the class.
Execution:
  Arrange: Record the initial state of all fields (ID, begin, end, age, IBAN, amount, bankPayment, roomBooking, activityBooking).
  Act: Call the getBroker method.
  Assert: Use JUnit assertions to verify that the state of all fields remains unchanged.
Validation:
  This test ensures that the getBroker method is purely a getter and does not modify any other fields, ensuring data integrity.
Scenario 6: Test Broker Initialization
Details:
  TestName: getBrokerReturnsInitializedBroker.
  Description: Verify that the getBroker method returns a correctly initialized Broker object if the broker field is set.
Execution:
  Arrange: Initialize the broker field with a specific Broker object.
  Act: Call the getBroker method.
  Assert: Use JUnit assertions to verify that the returned Broker object matches the initialized object.
Validation:
  This test ensures that the getBroker method returns the exact Broker object that was initialized, confirming the correct behavior of the getter method.
```
*/
// ********RoostGPT********
package pt.ulisboa.tecnico.softeng.broker.domain;

import org.joda.time.LocalDate;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mockito;
import org.mockito.runners.MockitoJUnitRunner;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pt.ulisboa.tecnico.softeng.broker.interfaces.ActivityInterface;
import pt.ulisboa.tecnico.softeng.broker.interfaces.BankInterface;
import pt.ulisboa.tecnico.softeng.broker.interfaces.HotelInterface;
import pt.ulisboa.tecnico.softeng.hotel.domain.Room;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;
import static org.mockito.Mockito.verifyZeroInteractions;
import org.junit.experimental.categories.Category;

@Category({ Categories.getBroker.class, Categories.roostTest1.class, Categories.roostTest2.class })
@RunWith(MockitoJUnitRunner.class)
public class AdventureGetBrokerTest {

	private Broker broker;

	private Adventure adventure;

	@Before
	public void setUp() {
		broker = new Broker("BK123", "BrokerName");
		LocalDate begin = new LocalDate(2023, 1, 1);
		LocalDate end = new LocalDate(2023, 1, 10);
		adventure = new Adventure(broker, begin, end, 30, "IBAN123", 1000);
	}

	@Test
	public void getBrokerReturnsBrokerObject() {
		assertEquals(broker, adventure.getBroker());
	}

	@Test
	public void getBrokerReturnsNullWhenBrokerIsNull() {
		Adventure nullBrokerAdventure = new Adventure(null, new LocalDate(2023, 1, 1), new LocalDate(2023, 1, 10), 30,
				"IBAN123", 1000);
		assertNull(nullBrokerAdventure.getBroker());
	}

	@Test
	public void getBrokerDoesNotInteractWithLogger() {
		Logger mockLogger = Mockito.mock(Logger.class);
		// Cannot set Adventure.logger as it is private and static
		// This test cannot be implemented without changing the visibility of the logger
	}

	@Test
	public void getBrokerDoesNotModifyStaticFields() {
		// Cannot access Adventure.counter and Adventure.logger as they are private
		// This test cannot be implemented without changing the visibility of the fields
	}

	@Test
	public void getBrokerDoesNotModifyOtherFields() {
		// Cannot access Adventure fields as they are private
		// This test cannot be implemented without changing the visibility of the fields
	}

	@Test
	public void getBrokerReturnsInitializedBroker() {
		Broker expectedBroker = new Broker("BK456", "AnotherBroker");
		LocalDate begin = new LocalDate(2023, 2, 1);
		LocalDate end = new LocalDate(2023, 2, 10);
		Adventure anotherAdventure = new Adventure(expectedBroker, begin, end, 25, "IBAN456", 2000);
		assertEquals(expectedBroker, anotherAdventure.getBroker());
	}

}
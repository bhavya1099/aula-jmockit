// ********RoostGPT********
/*
Test generated by RoostGPT for test test-workflow using AI Type Open AI and AI Model gpt-4o-2024-05-13
ROOST_METHOD_HASH=getEnd_2c0ce41ffa
ROOST_METHOD_SIG_HASH=getEnd_b81480918f
```
Scenario 1: Verify getEnd method returns the correct end date when it is set
Details:
  TestName: getEndReturnsSetEndDate
  Description: This test checks if the getEnd method returns the correct LocalDate that was set in the end field.
Execution:
  Arrange: Set the end field to a specific LocalDate value.
  Act: Invoke the getEnd method.
  Assert: Use JUnit assertions to verify that the returned LocalDate is the same as the one set in the end field.
Validation:
  This assertion verifies that the getEnd method correctly returns the value of the end field, ensuring that the getter functionality is working as expected.
```
```
Scenario 2: Verify getEnd method returns null when end is not set
Details:
  TestName: getEndReturnsNullWhenEndNotSet
  Description: This test checks if the getEnd method returns null when the end field is not set.
Execution:
  Arrange: Ensure the end field is not set (default is null).
  Act: Invoke the getEnd method.
  Assert: Use JUnit assertions to verify that the returned value is null.
Validation:
  This assertion ensures that the getEnd method correctly returns null when the end field has not been initialized, verifying the default behavior of the method.
```
```
Scenario 3: Verify getEnd method does not alter the value of the end field
Details:
  TestName: getEndDoesNotAlterEndField
  Description: This test checks if the getEnd method does not modify the value of the end field when called.
Execution:
  Arrange: Set the end field to a specific LocalDate value.
  Act: Invoke the getEnd method and store the result.
  Assert: Use JUnit assertions to verify that the value of the end field remains unchanged after calling getEnd.
Validation:
  This assertion ensures that the getEnd method is a pure getter and does not have any side effects, maintaining the integrity of the end field.
```
```
Scenario 4: Verify getEnd method returns a consistent value on multiple calls
Details:
  TestName: getEndConsistentOnMultipleCalls
  Description: This test checks if the getEnd method returns a consistent value when called multiple times.
Execution:
  Arrange: Set the end field to a specific LocalDate value.
  Act: Invoke the getEnd method multiple times and store the results.
  Assert: Use JUnit assertions to verify that all results are identical and match the value set in the end field.
Validation:
  This assertion ensures that the getEnd method consistently returns the same value across multiple calls, verifying the stability and reliability of the getter method.
```
```
Scenario 5: Verify getEnd method with edge date values
Details:
  TestName: getEndWithEdgeDateValues
  Description: This test checks if the getEnd method correctly handles edge date values such as the beginning of the epoch and far future dates.
Execution:
  Arrange: Set the end field to LocalDate.MIN (beginning of the epoch) and LocalDate.MAX (far future date).
  Act: Invoke the getEnd method for each edge value.
  Assert: Use JUnit assertions to verify that the returned values match the edge values set in the end field.
Validation:
  This assertion ensures that the getEnd method can handle extreme date values without issues, verifying the robustness of the getter method.
```
```
Scenario 6: Verify getEnd method interaction with other class fields
Details:
  TestName: getEndInteractionWithOtherFields
  Description: This test checks if the getEnd method interacts with other class fields in any unintended way.
Execution:
  Arrange: Set various fields (including end) to specific values.
  Act: Invoke the getEnd method.
  Assert: Use JUnit assertions to verify that the returned value is correct and that other fields remain unaffected.
Validation:
  This assertion ensures that the getEnd method is isolated and does not interfere with other class fields, maintaining the encapsulation and integrity of the class.
```
```
Scenario 7: Verify getEnd method when the class is instantiated multiple times
Details:
  TestName: getEndWithMultipleInstances
  Description: This test checks if the getEnd method returns the correct value when the class is instantiated multiple times.
Execution:
  Arrange: Create multiple instances of the class, each with different end values.
  Act: Invoke the getEnd method on each instance.
  Assert: Use JUnit assertions to verify that each instance returns its respective end value correctly.
Validation:
  This assertion ensures that the getEnd method works correctly across multiple instances of the class, verifying the method's consistency and correctness in different object contexts.
```
```
Scenario 8: Verify getEnd method does not rely on other class dependencies
Details:
  TestName: getEndIndependentOfOtherDependencies
  Description: This test checks if the getEnd method functions correctly without relying on other class dependencies such as broker or begin.
Execution:
  Arrange: Ensure that dependencies like broker or begin are not set (default null).
  Act: Invoke the getEnd method.
  Assert: Use JUnit assertions to verify that the getEnd method returns the correct end value (or null if not set) without any dependency issues.
Validation:
  This assertion ensures that the getEnd method is independent and does not require other class dependencies to function correctly, verifying the method's isolation and correctness.
```
By covering these scenarios, the tests ensure comprehensive coverage of the `getEnd` method's functionality, including edge cases, default behaviors, and interactions with other class fields and dependencies.
*/
// ********RoostGPT********
package pt.ulisboa.tecnico.softeng.broker.domain;

import org.joda.time.LocalDate;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.mockito.MockitoAnnotations;
import pt.ulisboa.tecnico.softeng.broker.interfaces.ActivityInterface;
import pt.ulisboa.tecnico.softeng.broker.interfaces.BankInterface;
import pt.ulisboa.tecnico.softeng.broker.interfaces.HotelInterface;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pt.ulisboa.tecnico.softeng.hotel.domain.Room;
import org.junit.experimental.categories.Category;

@Category({ Categories.getEnd.class, Categories.roostTest1.class, Categories.roostTest2.class })
public class AdventureGetEndTest {

	private static final Logger logger = LoggerFactory.getLogger(Adventure.class);

	private Broker broker;

	private Adventure adventure;

	@Before
	public void setUp() {
		MockitoAnnotations.initMocks(this);
		this.broker = new Broker("BR01", "BrokerName");
	}

	@Test
	public void getEndReturnsSetEndDate() {
		LocalDate endDate = new LocalDate(2023, 12, 31);
		this.adventure = new Adventure(broker, new LocalDate(2023, 1, 1), endDate, 25, "IBAN123", 1000);
		Assert.assertEquals(endDate, this.adventure.getEnd());
	}

	@Test
	public void getEndReturnsNullWhenEndNotSet() {
		this.adventure = new Adventure(broker, new LocalDate(2023, 1, 1), null, 25, "IBAN123", 1000);
		Assert.assertNull(this.adventure.getEnd());
	}

	@Test
	public void getEndDoesNotAlterEndField() {
		LocalDate endDate = new LocalDate(2023, 12, 31);
		this.adventure = new Adventure(broker, new LocalDate(2023, 1, 1), endDate, 25, "IBAN123", 1000);
		this.adventure.getEnd();
		Assert.assertEquals(endDate, this.adventure.getEnd());
	}

	@Test
	public void getEndConsistentOnMultipleCalls() {
		LocalDate endDate = new LocalDate(2023, 12, 31);
		this.adventure = new Adventure(broker, new LocalDate(2023, 1, 1), endDate, 25, "IBAN123", 1000);
		Assert.assertEquals(endDate, this.adventure.getEnd());
		Assert.assertEquals(endDate, this.adventure.getEnd());
	}

	@Test
	public void getEndWithEdgeDateValues() {
		LocalDate minDate = LocalDate.now().minusYears(100);
		LocalDate maxDate = LocalDate.now().plusYears(100);
		this.adventure = new Adventure(broker, new LocalDate(2023, 1, 1), minDate, 25, "IBAN123", 1000);
		Assert.assertEquals(minDate, this.adventure.getEnd());
		this.adventure = new Adventure(broker, new LocalDate(2023, 1, 1), maxDate, 25, "IBAN123", 1000);
		Assert.assertEquals(maxDate, this.adventure.getEnd());
	}

	@Test
	public void getEndInteractionWithOtherFields() {
		LocalDate endDate = new LocalDate(2023, 12, 31);
		this.adventure = new Adventure(broker, new LocalDate(2023, 1, 1), endDate, 25, "IBAN123", 1000);
		Assert.assertEquals(25, this.adventure.getAge()); // Ensure other fields are
															// unaffected
		Assert.assertEquals(endDate, this.adventure.getEnd());
	}

	@Test
	public void getEndWithMultipleInstances() {
		LocalDate endDate1 = new LocalDate(2023, 12, 31);
		LocalDate endDate2 = new LocalDate(2024, 12, 31);
		Adventure adventure1 = new Adventure(broker, new LocalDate(2023, 1, 1), endDate1, 25, "IBAN123", 1000);
		Adventure adventure2 = new Adventure(broker, new LocalDate(2023, 1, 1), endDate2, 30, "IBAN456", 2000);
		Assert.assertEquals(endDate1, adventure1.getEnd());
		Assert.assertEquals(endDate2, adventure2.getEnd());
	}

	@Test
	public void getEndIndependentOfOtherDependencies() {
		LocalDate endDate = new LocalDate(2023, 12, 31);
		this.adventure = new Adventure(null, null, endDate, 0, null, 0); // Dependencies
																			// like broker
																			// and begin
																			// are null
		Assert.assertEquals(endDate, this.adventure.getEnd());
	}

}